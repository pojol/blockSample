// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Avatar.proto

#ifndef PROTOBUF_Avatar_2eproto__INCLUDED
#define PROTOBUF_Avatar_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
class Avatar;
class AvatarDefaultTypeInternal;
extern AvatarDefaultTypeInternal _Avatar_default_instance_;
class BagGrid;
class BagGridDefaultTypeInternal;
extern BagGridDefaultTypeInternal _BagGrid_default_instance_;
class ItemInfo;
class ItemInfoDefaultTypeInternal;
extern ItemInfoDefaultTypeInternal _ItemInfo_default_instance_;

namespace protobuf_Avatar_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_Avatar_2eproto

enum Avatar_State {
  Avatar_State_LOGIN_READY = 0,
  Avatar_State_LOGIN_ING = 1,
  Avatar_State_LOGIN_SUCCESS = 2,
  Avatar_State_GAMING = 3,
  Avatar_State_JUMP_READY = 4,
  Avatar_State_JUMP_ING = 5,
  Avatar_State_JUMP_SUCCESS = 6,
  Avatar_State_LOGOUT_READY = 7,
  Avatar_State_LOGOUT_ING = 8,
  Avatar_State_LOGOUT_SUCCESS = 9,
  Avatar_State_Avatar_State_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Avatar_State_Avatar_State_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Avatar_State_IsValid(int value);
const Avatar_State Avatar_State_State_MIN = Avatar_State_LOGIN_READY;
const Avatar_State Avatar_State_State_MAX = Avatar_State_LOGOUT_SUCCESS;
const int Avatar_State_State_ARRAYSIZE = Avatar_State_State_MAX + 1;

const ::google::protobuf::EnumDescriptor* Avatar_State_descriptor();
inline const ::std::string& Avatar_State_Name(Avatar_State value) {
  return ::google::protobuf::internal::NameOfEnum(
    Avatar_State_descriptor(), value);
}
inline bool Avatar_State_Parse(
    const ::std::string& name, Avatar_State* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Avatar_State>(
    Avatar_State_descriptor(), name, value);
}
// ===================================================================

class ItemInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ItemInfo) */ {
 public:
  ItemInfo();
  virtual ~ItemInfo();

  ItemInfo(const ItemInfo& from);

  inline ItemInfo& operator=(const ItemInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ItemInfo& default_instance();

  static inline const ItemInfo* internal_default_instance() {
    return reinterpret_cast<const ItemInfo*>(
               &_ItemInfo_default_instance_);
  }

  void Swap(ItemInfo* other);

  // implements Message ----------------------------------------------

  inline ItemInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ItemInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ItemInfo& from);
  void MergeFrom(const ItemInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ItemInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 3;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // int64 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // uint32 dictId = 2;
  void clear_dictid();
  static const int kDictIdFieldNumber = 2;
  ::google::protobuf::uint32 dictid() const;
  void set_dictid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ItemInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int64 id_;
  ::google::protobuf::uint32 dictid_;
  mutable int _cached_size_;
  friend struct  protobuf_Avatar_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BagGrid : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:BagGrid) */ {
 public:
  BagGrid();
  virtual ~BagGrid();

  BagGrid(const BagGrid& from);

  inline BagGrid& operator=(const BagGrid& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BagGrid& default_instance();

  static inline const BagGrid* internal_default_instance() {
    return reinterpret_cast<const BagGrid*>(
               &_BagGrid_default_instance_);
  }

  void Swap(BagGrid* other);

  // implements Message ----------------------------------------------

  inline BagGrid* New() const PROTOBUF_FINAL { return New(NULL); }

  BagGrid* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BagGrid& from);
  void MergeFrom(const BagGrid& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BagGrid* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ItemInfo info = 1;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 1;
  const ::ItemInfo& info() const;
  ::ItemInfo* mutable_info();
  ::ItemInfo* release_info();
  void set_allocated_info(::ItemInfo* info);

  // uint32 pos = 2;
  void clear_pos();
  static const int kPosFieldNumber = 2;
  ::google::protobuf::uint32 pos() const;
  void set_pos(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:BagGrid)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ItemInfo* info_;
  ::google::protobuf::uint32 pos_;
  mutable int _cached_size_;
  friend struct  protobuf_Avatar_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Avatar : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Avatar) */ {
 public:
  Avatar();
  virtual ~Avatar();

  Avatar(const Avatar& from);

  inline Avatar& operator=(const Avatar& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Avatar& default_instance();

  static inline const Avatar* internal_default_instance() {
    return reinterpret_cast<const Avatar*>(
               &_Avatar_default_instance_);
  }

  void Swap(Avatar* other);

  // implements Message ----------------------------------------------

  inline Avatar* New() const PROTOBUF_FINAL { return New(NULL); }

  Avatar* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Avatar& from);
  void MergeFrom(const Avatar& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Avatar* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Avatar_State State;
  static const State LOGIN_READY =
    Avatar_State_LOGIN_READY;
  static const State LOGIN_ING =
    Avatar_State_LOGIN_ING;
  static const State LOGIN_SUCCESS =
    Avatar_State_LOGIN_SUCCESS;
  static const State GAMING =
    Avatar_State_GAMING;
  static const State JUMP_READY =
    Avatar_State_JUMP_READY;
  static const State JUMP_ING =
    Avatar_State_JUMP_ING;
  static const State JUMP_SUCCESS =
    Avatar_State_JUMP_SUCCESS;
  static const State LOGOUT_READY =
    Avatar_State_LOGOUT_READY;
  static const State LOGOUT_ING =
    Avatar_State_LOGOUT_ING;
  static const State LOGOUT_SUCCESS =
    Avatar_State_LOGOUT_SUCCESS;
  static inline bool State_IsValid(int value) {
    return Avatar_State_IsValid(value);
  }
  static const State State_MIN =
    Avatar_State_State_MIN;
  static const State State_MAX =
    Avatar_State_State_MAX;
  static const int State_ARRAYSIZE =
    Avatar_State_State_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  State_descriptor() {
    return Avatar_State_descriptor();
  }
  static inline const ::std::string& State_Name(State value) {
    return Avatar_State_Name(value);
  }
  static inline bool State_Parse(const ::std::string& name,
      State* value) {
    return Avatar_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .BagGrid grids = 7;
  int grids_size() const;
  void clear_grids();
  static const int kGridsFieldNumber = 7;
  const ::BagGrid& grids(int index) const;
  ::BagGrid* mutable_grids(int index);
  ::BagGrid* add_grids();
  ::google::protobuf::RepeatedPtrField< ::BagGrid >*
      mutable_grids();
  const ::google::protobuf::RepeatedPtrField< ::BagGrid >&
      grids() const;

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // int64 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // .Avatar.State state = 3;
  void clear_state();
  static const int kStateFieldNumber = 3;
  ::Avatar_State state() const;
  void set_state(::Avatar_State value);

  // uint32 hp = 4;
  void clear_hp();
  static const int kHpFieldNumber = 4;
  ::google::protobuf::uint32 hp() const;
  void set_hp(::google::protobuf::uint32 value);

  // uint32 mp = 5;
  void clear_mp();
  static const int kMpFieldNumber = 5;
  ::google::protobuf::uint32 mp() const;
  void set_mp(::google::protobuf::uint32 value);

  // uint32 gold = 6;
  void clear_gold();
  static const int kGoldFieldNumber = 6;
  ::google::protobuf::uint32 gold() const;
  void set_gold(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Avatar)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::BagGrid > grids_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int64 id_;
  int state_;
  ::google::protobuf::uint32 hp_;
  ::google::protobuf::uint32 mp_;
  ::google::protobuf::uint32 gold_;
  mutable int _cached_size_;
  friend struct  protobuf_Avatar_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ItemInfo

// int64 id = 1;
inline void ItemInfo::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ItemInfo::id() const {
  // @@protoc_insertion_point(field_get:ItemInfo.id)
  return id_;
}
inline void ItemInfo::set_id(::google::protobuf::int64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:ItemInfo.id)
}

// uint32 dictId = 2;
inline void ItemInfo::clear_dictid() {
  dictid_ = 0u;
}
inline ::google::protobuf::uint32 ItemInfo::dictid() const {
  // @@protoc_insertion_point(field_get:ItemInfo.dictId)
  return dictid_;
}
inline void ItemInfo::set_dictid(::google::protobuf::uint32 value) {
  
  dictid_ = value;
  // @@protoc_insertion_point(field_set:ItemInfo.dictId)
}

// string name = 3;
inline void ItemInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ItemInfo::name() const {
  // @@protoc_insertion_point(field_get:ItemInfo.name)
  return name_.GetNoArena();
}
inline void ItemInfo::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ItemInfo.name)
}
#if LANG_CXX11
inline void ItemInfo::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ItemInfo.name)
}
#endif
inline void ItemInfo::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ItemInfo.name)
}
inline void ItemInfo::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ItemInfo.name)
}
inline ::std::string* ItemInfo::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:ItemInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ItemInfo::release_name() {
  // @@protoc_insertion_point(field_release:ItemInfo.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ItemInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:ItemInfo.name)
}

// -------------------------------------------------------------------

// BagGrid

// .ItemInfo info = 1;
inline bool BagGrid::has_info() const {
  return this != internal_default_instance() && info_ != NULL;
}
inline void BagGrid::clear_info() {
  if (GetArenaNoVirtual() == NULL && info_ != NULL) delete info_;
  info_ = NULL;
}
inline const ::ItemInfo& BagGrid::info() const {
  // @@protoc_insertion_point(field_get:BagGrid.info)
  return info_ != NULL ? *info_
                         : *::ItemInfo::internal_default_instance();
}
inline ::ItemInfo* BagGrid::mutable_info() {
  
  if (info_ == NULL) {
    info_ = new ::ItemInfo;
  }
  // @@protoc_insertion_point(field_mutable:BagGrid.info)
  return info_;
}
inline ::ItemInfo* BagGrid::release_info() {
  // @@protoc_insertion_point(field_release:BagGrid.info)
  
  ::ItemInfo* temp = info_;
  info_ = NULL;
  return temp;
}
inline void BagGrid::set_allocated_info(::ItemInfo* info) {
  delete info_;
  info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:BagGrid.info)
}

// uint32 pos = 2;
inline void BagGrid::clear_pos() {
  pos_ = 0u;
}
inline ::google::protobuf::uint32 BagGrid::pos() const {
  // @@protoc_insertion_point(field_get:BagGrid.pos)
  return pos_;
}
inline void BagGrid::set_pos(::google::protobuf::uint32 value) {
  
  pos_ = value;
  // @@protoc_insertion_point(field_set:BagGrid.pos)
}

// -------------------------------------------------------------------

// Avatar

// int64 id = 1;
inline void Avatar::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Avatar::id() const {
  // @@protoc_insertion_point(field_get:Avatar.id)
  return id_;
}
inline void Avatar::set_id(::google::protobuf::int64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:Avatar.id)
}

// string name = 2;
inline void Avatar::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Avatar::name() const {
  // @@protoc_insertion_point(field_get:Avatar.name)
  return name_.GetNoArena();
}
inline void Avatar::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Avatar.name)
}
#if LANG_CXX11
inline void Avatar::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Avatar.name)
}
#endif
inline void Avatar::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Avatar.name)
}
inline void Avatar::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Avatar.name)
}
inline ::std::string* Avatar::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Avatar.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Avatar::release_name() {
  // @@protoc_insertion_point(field_release:Avatar.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Avatar::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Avatar.name)
}

// .Avatar.State state = 3;
inline void Avatar::clear_state() {
  state_ = 0;
}
inline ::Avatar_State Avatar::state() const {
  // @@protoc_insertion_point(field_get:Avatar.state)
  return static_cast< ::Avatar_State >(state_);
}
inline void Avatar::set_state(::Avatar_State value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:Avatar.state)
}

// uint32 hp = 4;
inline void Avatar::clear_hp() {
  hp_ = 0u;
}
inline ::google::protobuf::uint32 Avatar::hp() const {
  // @@protoc_insertion_point(field_get:Avatar.hp)
  return hp_;
}
inline void Avatar::set_hp(::google::protobuf::uint32 value) {
  
  hp_ = value;
  // @@protoc_insertion_point(field_set:Avatar.hp)
}

// uint32 mp = 5;
inline void Avatar::clear_mp() {
  mp_ = 0u;
}
inline ::google::protobuf::uint32 Avatar::mp() const {
  // @@protoc_insertion_point(field_get:Avatar.mp)
  return mp_;
}
inline void Avatar::set_mp(::google::protobuf::uint32 value) {
  
  mp_ = value;
  // @@protoc_insertion_point(field_set:Avatar.mp)
}

// uint32 gold = 6;
inline void Avatar::clear_gold() {
  gold_ = 0u;
}
inline ::google::protobuf::uint32 Avatar::gold() const {
  // @@protoc_insertion_point(field_get:Avatar.gold)
  return gold_;
}
inline void Avatar::set_gold(::google::protobuf::uint32 value) {
  
  gold_ = value;
  // @@protoc_insertion_point(field_set:Avatar.gold)
}

// repeated .BagGrid grids = 7;
inline int Avatar::grids_size() const {
  return grids_.size();
}
inline void Avatar::clear_grids() {
  grids_.Clear();
}
inline const ::BagGrid& Avatar::grids(int index) const {
  // @@protoc_insertion_point(field_get:Avatar.grids)
  return grids_.Get(index);
}
inline ::BagGrid* Avatar::mutable_grids(int index) {
  // @@protoc_insertion_point(field_mutable:Avatar.grids)
  return grids_.Mutable(index);
}
inline ::BagGrid* Avatar::add_grids() {
  // @@protoc_insertion_point(field_add:Avatar.grids)
  return grids_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::BagGrid >*
Avatar::mutable_grids() {
  // @@protoc_insertion_point(field_mutable_list:Avatar.grids)
  return &grids_;
}
inline const ::google::protobuf::RepeatedPtrField< ::BagGrid >&
Avatar::grids() const {
  // @@protoc_insertion_point(field_list:Avatar.grids)
  return grids_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Avatar_State> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Avatar_State>() {
  return ::Avatar_State_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Avatar_2eproto__INCLUDED
